<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../iron-menu-behavior/iron-menubar-behavior.html">
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="step-horizontal-label.html">

<dom-module id="paper-horizontal-labels-container">
  <template>
    <style>
      :host {
        @apply --layout-horizontal;
        @apply --layout-flex-none;
        @apply --layout-justified;
        background: var(--paper-stepper-horizontal-label-wrapper-background);
        @apply --paper-stepper-horizontal-header;
      }
    </style>

    <slot id="labelTemplateSlot" name="horizontal-step-label-template">
      <template>
        <step-horizontal-label
          editable="{{editable}}"
          label="{{label}}"
          optional="[[optional]]"
          opened$="{{opened}}"
          selectable="[[selectable]]"
          index="{{index}}"
          saved="{{saved}}"
          disabled="[[disabled]]"
          step="[[step]]"
          alternative-label="[[alternativeLabel]]"
        ></step-horizontal-label>
      </template>
    </slot>

    <slot></slot>

  </template>
  <script>
    Polymer({
      is: 'paper-horizontal-labels-container',

      behaviors: [
        Polymer.IronMenubarBehavior,
        Polymer.Templatizer
      ],

      properties: {
        alternativeLabel: {
          type: Boolean,
          value: false
        },
        steps: {
          type: Array
        }
      },

      observers: [
        '_updateAlternativeLabels(alternativeLabel, items.*)',
        '_stepsChanged(steps)'
      ],

      updateTemplate: function() {
        if (Polymer.Element) {
          if (!this.LabelTemplateClass) {
            var labelTemplateSlot = this.getContentChildren('#labelTemplateSlot')[0];
            this.LabelTemplateClass = Polymer.Templatize.templatize(labelTemplateSlot, this);
          }
        } else {
          var labelTemplateSlot = this.getContentChildren('#labelTemplateSlot')[0];
          this.templatize(labelTemplateSlot);
        }
      },

      _stepsChanged: function(steps) {
        this.updateTemplate();
        Array.prototype.forEach.call(steps, this._ensureStepLabel.bind(this));
      },

      _ensureStepLabel: function(step) {
        // If the label for this step doesn't exist or isn't inserted into
        // this element's shadow DOM
        var label = step.horizontalLabelNode;
        // TODO: replace the seconde condition with step.horizontalLabelElement == step.labelElement ?
        if (!label || Polymer.dom(label).parentNode != this) {
          label = step.labelElement = step.horizontalLabelElement = Polymer.Element ?
            new this.LabelTemplateClass({step: step}): this.stamp({step: step});
          if (Polymer.Element) {
            label.step = step;
          }
          Polymer.dom(this).appendChild(label.root);
          step.horizontalLabelNode = Polymer.Element ? label.root.nodeList[0] : label._nodes[0];
          step.horizontalLabelNode.style.order = step.index - 1;
          step.horizontalLabelNode.setAttribute(this.attrForSelected, step.getAttribute(this.attrForSelected));
        }
      },

      _updateAlternativeLabels(alternativeLabel) {
        if (this.items && this.items.length) {
          this.items.forEach(function(step) {
            step.alternativeLabel = alternativeLabel;
          });
        }
      },

    });
  </script>
</dom-module>
