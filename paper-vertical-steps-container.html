<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../iron-collapse/iron-collapse.html">
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="step-vertical-label.html">
<link rel="import" href="paper-vertical-step-collapse.html">

<dom-module id="paper-vertical-steps-container">
  <template>
    <style>
      :host {
        @apply --layout-vertical;
      }
    </style>

    <slot
      id="verticalStepLabelTemplateSlot"
      name="vertical-step-label-template"
    >
      <template>
        <step-vertical-label
          editable="{{editable}}"
          label="{{label}}"
          optional="[[optional]]"
          opened$="{{opened}}"
          index="{{index}}"
          saved="{{saved}}"
          disabled="[[disabled]]"
          step="[[step]]"
        ></step-vertical-label>
      </template>
    </slot>

    <slot
      id="verticalStepWrapperTemplateSlot"
      name="vertical-step-wrapper-template"
    >
      <template>
        <paper-vertical-step-collapse opened="[[opened]]">
          <slot></slot>
        </paper-vertical-step-collapse>
      </template>
    </slot>

    <slot id="slot"></slot>

  </template>
  <script>
    Polymer({
      is: 'paper-vertical-steps-container',

      behaviors: [
        Polymer.Templatizer
      ],

      /**
       * The set of excluded elements where the key is the `localName`
       * of the element that will be ignored from the item list.
       *
       * @default {template: 1}
       */
      _excludedLocalNames: {
        'template': true,
        'dom-bind': true,
        'dom-if': true,
        'dom-repeat': true
      },

      attached: function() {
        this._observeItems(this);
      },

      _observeItems: function(node) {
        Polymer.dom(node).observeNodes(function(mutation) {
          // TODO: keep a reference to the templatized, inserted, appended, labelized step
          mutation.addedNodes.length &&
          this._processAddedSteps(this._filterSteps(mutation.addedNodes));

          mutation.removedNodes.length &&
          this._processRemovedSteps(this._filterSteps(mutation.removedNodes));
        }.bind(this));
      },

      _processAddedSteps: function(steps) {
        // TODO: check templates validity
        if (Polymer.Element) {
          if (!this.LabelTemplateClass) {
            var verticalStepLabelTemplate = this.getContentChildren('#verticalStepLabelTemplateSlot')[0];
            this.LabelTemplateClass = Polymer.Templatize.templatize(verticalStepLabelTemplate, this);
          }
          if (!this.StepTemplateClass) {
            var verticalStepWrapperTemplateSlot = this.getContentChildren('#verticalStepWrapperTemplateSlot')[0];
            this.StepTemplateClass = Polymer.Templatize.templatize(verticalStepWrapperTemplateSlot, this);
          }
        } else {
          var verticalStepLabelTemplate = this.getContentChildren('#verticalStepLabelTemplateSlot')[0];
          this.templatize(verticalStepLabelTemplate);
        }
        Array.prototype.forEach.call(steps, this._ensureVerticalLabel.bind(this));

        if (!Polymer.Element) {
          var verticalStepWrapperTemplateSlot = this.getContentChildren('#verticalStepWrapperTemplateSlot')[0];
          this.templatize(verticalStepWrapperTemplateSlot);
        }
        Array.prototype.forEach.call(steps, this._ensureStepInsertion.bind(this));

      },

      _processRemovedSteps: function(steps) {
        // Array.prototype.forEach.call(steps, this._resetStepInsertion.bind(this));
      },

      _filterSteps: function(nodes) {
        return Array.prototype.filter.call(nodes, this.isStep.bind(this));
      },

      /**
       * Return true if the node is a step.
       * @param  {HTMLElement} node The node to test.
       * @return {Boolean}          True if the ode is a step.
       */
      isStep: function(node) {
        return node.localName && !this._excludedLocalNames[node.localName];
      },

      _resetStepInsertion: function(step) {
        // step.removeAttribute('slot');
        // TODO
      },

      _handleStepOpenedChanged: function(e) {
        var step = Polymer.dom(e).rootTarget;
        step.verticalStepWrapper.set('opened', e.detail.value)
      },

      _ensureStepInsertion: function(step) {
        var slotName = 'vertical-step-' + step.index;

        step.setAttribute('slot', slotName);

        // WORKAROUND: This is not the good way to do it
        if (step.verticalStepWrapper) return;

        var
          stepContainer = step.verticalStepWrapper = Polymer.Element ?
            new this.StepTemplateClass({opened: step.opened}): this.stamp({opened: step.opened}),
          stepContainerRoot = stepContainer.root,
          stepContainerChildren = stepContainerRoot.children,
          slot = this._findSlot(stepContainerChildren);

        if (Polymer.Element) {
          stepContainer.opened = step.opened;
        }

        if (slot) {
          this._setSlotName(slot, slotName);
        }
        Polymer.dom(this.root).insertBefore(stepContainerRoot, Polymer.dom(step.verticalLabelNode).nextElementSibling);
        this.listen(step, 'opened-changed', '_handleStepOpenedChanged');

        if (Polymer.Element) {
          // For native shadow DOM v1, a default slot doesn't match children with an explicit slot name
          var slot = document.createElement('slot');
          slot.setAttribute('name', slotName);
          slot.setAttribute('slot', slotName);
          Polymer.dom(this).appendChild(slot);
        }
      },

      _findSlot(nodes) {
        var slot, slotLocalName = Polymer.Element ? 'slot' : 'content';
        for (var i = 0; !slot && i < nodes.length; i++) {
          slot = Polymer.dom(nodes[i]).querySelector(slotLocalName);
        };
        return slot;
      },

      _ensureVerticalLabel: function(step) {
        var label = step.verticalLabelNode;
        // If the label for this step doesn't exist or isn't inserted into
        // this element's shadow DOM
        // TODO: replace the seconde condition with step.horizontalLabelElement == step.labelElement ?
        if (!label || Polymer.dom(label).parentNode != this.root) {
          label = step.labelElement = step.verticalLabelElement = Polymer.Element ?
           new this.LabelTemplateClass({step: step}): this.stamp({step: step});
          if (Polymer.Element) {
            // work-around for LabelTemplateClass({step: step}) that doesn't set step
            step.labelElement.step = step;
          }
          Polymer.dom(this.root).insertBefore(label.root, this.$.slot);
          step.verticalLabelNode = Polymer.Element ? label.root.nodeList[0] : label._nodes[0];
          this.listen(step.verticalLabelNode, 'tap', '_handleLabelTap');
        }
      },

      _handleLabelTap: function(e) {
        Polymer.dom(e).rootTarget.step.select();
      },

      ensureVerticalStepSlot(index) {
        if (!this._getVerticalStepSlot(index)) {
          this._addVerticalStepSlot(index);
        }
      },

      _getVerticalStepSlot: function(index) {
        return this.$$( Polymer.Element ?
          'slot[name=\'vertical-step-' + index + '\']' :
          'content[select="[slot=\'vertical-step-' + index + '\']"]'
        );
      },

      _addVerticalStepSlot: function(index) {
        Polymer.dom(this.root).insertBefore(this.createSlot('vertical-step-' + index), this.$.slot);
      },

      createSlot: function(name) {
        var slot;
        if (Polymer.Element) {
          slot = document.createElement('slot');
          if (name) slot.setAttribute('name', name);
        } else {
          slot = document.createElement('content');
          if (name) slot.setAttribute('select', "[slot='" + name + "']");
        }
        return slot;
      },

      _setSlotName: function(slot, name) {
        if (Polymer.Element) {
          slot.setAttribute('name', name);
        } else {
          slot.setAttribute('select', "[slot='" + name + "']");
        }
      }

    });
  </script>
</dom-module>
